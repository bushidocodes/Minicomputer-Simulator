LDR 1,0,16;    initialize the DATALOC variable - load R1 with the first program instruction address
LDX 2,0,30;       load IX2 with the pointer to the start of the base address table
LDX 3,2,1;        load IX3 with the pointer to the first data value in base address table
LDX 2,3,3;        load IX2 with the third data value in the base address table (96)
STX 2,0,17;       store value 96 into user reserved mem loc 17
AMR 1,0,17;       add value 96 from mem loc 17 to register 1
STR 1,0,19;       store the value of DATALOC (program start + 96) into reserved mem loc 19
LDR 2,0,31;    initialize the COUNTER variable - zero out R2
AIR 2,20;         add immediate 20 to register 2 for loop COUNTER variable
LDA 1,0,16,1;  initialize POINTERS - load program start address into R1
AIR 1,20;         ptr_LOOP_1_START add immediate 20 to R1 (this is the address of LOOP_1 start)
STR 1,0,23;       store ptr_LOOP_1_START in reserved memory location 23
AIR 1,31;         add immediate 11 to R1 (total 31) to calculate the instruction offset for instructions >31
STR 1,0,17;       ptr_INSTRUCTION_OFFSET store value (program start + 31) into user reserved mem loc 17
LDX 2,0,17;       load value (program start + 31) into IX2. this is the address of the 32nd instruction
SRC 1,8,1,0;   initialize CLOSEST_DISTANCE variable to max value (65535). Lsh R1 by 8 bits to get 1000 0100 0000 0000
SRC 1,15,0,0;     Rsh R1 arithmetically 15 bits to get 1111 1111 1111 1111 (max value)
STR 1,0,18;       store max value from R1 into user reserved memory loc 18
LDX 1,0,29;    line break character -- load the pointer to the start of the ASCII Table into IX1
LDX 3,1,1;        loads ASCII 0 in IX3 to be used for printing line breaks later
IN 1,0;        LOOP_1: store the input from console keyboard in R1
OUT 1,1;          print the value in R1 to the console printer
LDR 0,3,10;       load ASCII new line character
OUT 0,1;          print ASCII new line character
STR 1,0,19,1;     store the input value from register 1 into mem(DATALOC) indirect
LDR 3,0,19;       load DATALOC variable into R3 from mem loc 19
AIR 3,1;          increment DATALOC variable by 1
STR 3,0,19;       store DATALOC variable from R3 back into mem loc 19/
SOB 2,0,23,1;     END LOOP_1: subtract 1 from R2 (COUNTER). if c(R2) > 0, set PC to beginning of loop_1
HLT; only debugged up until this point. abandon all hope ye who pass this point.
IN 0,0;        read one additional number USER_NUM from the user into R0
STR 0,1,3;     store USER_NUM in memory loc IX1+3
AIR 2,20;      add immediate 20 to register 2 to reset loop COUNTER variable.
SIR 3,20;      subtract immediate 20 from register 3 to set DATALOC pointer back to 130
STR 3,1,2;     store DATALOC from R3 into memory loc IX1+2
LDR 0,1,3;     LOOP_2: load R0 with USER_NUM (which is in loc IX1+3)
SMR 0,1,2,1;     subtract the current number (mem[DATALOC]) from R0(USER_NUM)
JGE 0,2,10;      if the diff that remains in R0 is >= 0 then jump to LT (address 42)
LDR 1,1,2,1;     GT: else the diff is < 0. NUM_DATALOC is greater than USER_NUM so DISTANCE = NUM_DATALOC - USER_NUM. load NUM_DATALOC into R1
SMR 1,1,3;         subtract USER_NUM from R1(NUM_DATALOC) -- distance between numbers is in R1 now
STR 1,1,4;         store the distance in memory location IX1+4
JMA 2,14;          jump to CHECKDISTANCE (address 46)
JZ 0,2,13;       LT: if the value in R0 is zero, jump to ZERO (address 45)
STR 0,1,4;         else the diff is in R0 currently. store the current number distance in memory location IX1+4
JMA 2,14;          jump to CHECKDISTANCE (address 46)
STR 1,1,4;       ZERO: USER_NUM is exactly equal to NUM_DATALOC. Store the distance (0) in memory location IX1+4.
LDR 0,1,1;       CHECKDISTANCE: load the closest distance variable (mem loc IX1+1) into R0
SMR 0,1,4;         subtract the current number distance (memloc IX1+4) from the closest distance number (R0)
JGE 0,2,21;        if the diff that remains in R0 is >= 0 then jump to NEWCLOSEST (address 52)
JMA 2,22;          otherwise, this number is not closer, jump to LOOP2COUNTERS to increment loop
LDR 0,1,4;       NEWCLOSEST: reload current number distance into R0 -- fixes an issue on the first iteration
STR 0,1,1;         the current number distance is less than closest distance, therefore curr number distance is closer so replace it in mem loc IX1+1
LDR 1,1,2,1;       load the current number (IX1+2 indirect) in R1
STR 1,1,5;         store the number from R1 (which has been found as the new closest number) into mem loc IX1+5
LDR 3,1,2;       LOOP2COUNTERS: load DATALOC (mem loc IX1+2) variable into R3
AIR 3,1;           increment DATALOC variable by 1
STR 3,1,2;         store DATALOC variable from R3 back into memory loc IX1+2
SOB 2,2,2;     END LOOP_2: subtract 1 from R2 (COUNTER). if c(R2) > 0, set PC to address 33 (beginning of loop_2)
LDR 1,1,3;     load the user number (mem loc IX1+3) into register 1
OUT 1,1;       print user number
LDR 1,1,5;     load the closest number (mem loc IX1+5) into register 1
OUT 1,1;       print user number
HLT;           end of program