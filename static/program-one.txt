AIR 2,20; add immediate 20 to register 2 for loop COUNTER variable.
AIR 1,31; add immediate 31 to R1 to be eventually loaded into X2
STR 1,0,6; store value 31 from R1 into mem loc 6
LDX 2,0,6; load value 31 from mem loc 6 into X2
SRC 1,2,1,0; shift R1 left by 2 bits to get 124
STR 1,0,6; store value 124 from R1 into mem loc 6
LDX 1,0,6; load value 124 from mem loc 6 into X1
AIR 1,6; add immediate 6 to register 1 to get 130 for DATALOC variable.
STR 1,0,6; store value 130 into mem loc 6 to be moved to register 3
LDR 3,0,6; load register 3 with value 130
SRC 1,8,1,0; shift R1 LEFT by 8 bits to get 1000 0010 0000 0000
SRC 1,15,0,0; shift R1 RIGHT arithmetically 15 bits to get 1111 1111 1111 1111 (max value) -- returns -1??
STR 1,1,1; store max value from R1 into memory loc X1+1
STR 3,1,2; store DATALOC from R3 into memory loc X1+2
IN 1,0; LOOP_1: store the input from console keyboard in R1
OUT 1,1; print the value in R1 to the console printer
STR 1,1,2,1; store the input value in register 1 into mem(DATALOC) indirect
LDR 3,1,2; load DATALOC variable into R3
AIR 3,1; increment DATALOC variable by 1
STR 3,1,2; store DATALOC variable from R3 back into memory loc X1+2
SOB 2,0,21; END LOOP_1: subtract 1 from R2 (COUNTER). if c(R2) > 0, set PC to address 21 (beginning of loop_1)
IN 0,0; read one additional number USER_NUM from the user into R0
STR 0,1,3; store USER_NUM in memory loc X1+3
AIR 2,20; add immediate 20 to register 2 to reset loop COUNTER variable.
SIR 3,20; subtract immediate 20 from register 3 to set DATALOC pointer back to 130
STR 3,1,2; store DATALOC from R3 into memory loc X1+2
LDR 0,1,3; LOOP_2: load R0 with USER_NUM (which is in loc X1+3)
SMR 0,1,2,1; subtract the current number (mem[DATALOC]) from R0(USER_NUM)
JGE 0,2,10; if the diff that remains in R0 is >= 0 then jump to LT (address 42)
LDR 1,1,2,1; GT: else the diff is < 0. NUM_DATALOC is greater than USER_NUM so DISTANCE = NUM_DATALOC - USER_NUM. load NUM_DATALOC into R1
SMR 1,1,3; subtract USER_NUM from R1(NUM_DATALOC) -- distance between numbers is in R1 now
STR 1,1,4; store the distance in memory location X1+4
JMA 2,14; jump to CHECKDISTANCE (address 46)
JZ 0,2,13; LT: if the value in R0 is zero, jump to ZERO (address 45)
STR 0,1,4; else the diff is in R0 currently. store the current number distance in memory location X1+4
JMA 2,14; jump to CHECKDISTANCE (address 46)
STR 1,1,4; ZERO: USER_NUM is exactly equal to NUM_DATALOC. Store the distance (0) in memory location X1+4.
LDR 0,1,1; CHECKDISTANCE: load the closest distance variable (mem loc X1+1) into R0
SMR 0,1,4; subtract the current number distance (memloc X1+4) from the closest distance number (R0)
JGE 0,2,21; if the diff that remains in R0 is >= 0 then jump to NEWCLOSEST (address 52)
JMA 2,22; otherwise, this number is not closer, jump to LOOP2COUNTERS to increment loop
LDR 0,1,4; NEWCLOSEST: reload current number distance into R0 -- fixes an issue on the first iteration
STR 0,1,1; the current number distance is less than closest distance, therefore curr number distance is closer so replace it in mem loc X1+1
LDR 1,1,2,1; load the current number (X1+2 indirect) in R1
STR 1,1,5; store the number from R1 (which has been found as the new closest number) into mem loc X1+5
LDR 3,1,2; LOOP2COUNTERS: load DATALOC (mem loc X1+2) variable into R3
AIR 3,1; increment DATALOC variable by 1
STR 3,1,2; store DATALOC variable from R3 back into memory loc X1+2
SOB 2,2,2; END LOOP_2: subtract 1 from R2 (COUNTER). if c(R2) > 0, set PC to address 33 (beginning of loop_2)
LDR 1,1,3; load the user number (mem loc X1+3) into register 1
OUT 1,1; print user number
LDR 1,1,5; load the closest number (mem loc X1+5) into register 1
OUT 1,1; print user number